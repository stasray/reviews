# Тестирование и производительность проекта

Этот документ описывает, как запустить модульные тесты, посмотреть покрытие кода, выполнить веб‑тест производительности, сделать профайлинг (нагрузочное тестирование) и запустить GUI‑тесты Streamlit.

## Предварительная подготовка

- Python 3.10+
- Рекомендуется виртуальное окружение (`.venv`)
- Установка зависимостей:

```bash
# Активировать venv (если уже создан)
source .venv/bin/activate 2>/dev/null || true

# Базовые зависимости приложения
pip install -r requirements.txt

# Инструменты тестирования
pip install pytest coverage
```

## 1) Модульное тестирование

Где находится:
- Код приложения: `src/`
- Unit‑тесты: `tests/test_services.py`

Шаги:
- Открыть исходный код тестируемого приложения (например, `src/services.py`).
- Добавить/изучить Unit‑тесты для выбранных функций (см. `tests/test_services.py`).
- Запустить тесты и просмотреть результаты:

```bash
make test        # или: pytest -q
```

- Создать несколько разных тестов (на значения и перехват исключений):
  - Примеров уже достаточно в `tests/test_services.py` (проверка значений, путей парсинга, загрузки файлов и т. д.).
  - Добавляйте новые кейсы по аналогии.

## 2) Покрытие кода тестами

Где настраивается:
- Файл `.coveragerc` — параметры сбора покрытия (источники, исключения, формат отчетов).
- Файл `pytest.ini` — базовые опции pytest.

Шаги:
- Запустить тесты с покрытием и посмотреть отчет:

```bash
make test-cov         # текстовый отчет + coverage.xml
make test-cov-html    # HTML‑отчет в .coverage_html/index.html
```

- Просмотр результатов:
  - Текстовый отчет — в консоли.
  - XML — файл `coverage.xml`.
  - HTML — открыть `.coverage_html/index.html` в браузере.

## 3) Веб‑тесты производительности

Где находится:
- Скрипт: `scripts/web_perf_test.py`
- Сценарий: `perf/scenario_example.json`

Сценарий можно править: базовый URL, список шагов (метод, путь, заголовки, вес). Вес влияет на вероятность выбора шага.

Запуск (пример):

```bash
# Быстрый прогон против example.com
make web-perf

# Кастомный сайт/параметры нагрузки (без файла сценария)
python scripts/web_perf_test.py \
  --base-url https://your-site.tld \
  --rate 10 --concurrency 10 --duration 30

# С использованием своего сценария JSON
python scripts/web_perf_test.py \
  --scenario perf/scenario_example.json \
  --rate 20 --concurrency 20 --duration 60
```

Результат: сводка в JSON (RPS, p50/p90/p99, коды ответа, байты/сек, статистика по шагам) выводится в консоль.

## 4) Нагрузочное тестирование (профайлинг приложения)

Где находится:
- Скрипт профилирования: `scripts/profile_analysis.py`

Что делает: прогоняет `run_analysis` на наборах фейковых отзывов (по умолчанию 50/200/500), замеряет время и пиковую память (`tracemalloc`). Тяжелые зависимости LLM и эмбеддингов заглушены для стабильных измерений.

Запуск:

```bash
make profile
# либо с явными размерами
python scripts/profile_analysis.py --sizes "50,200,500" --out profile_results.json
```

Результат: табличный вывод в консоли и JSON `profile_results.json` с метриками на каждый размер.

## 5) Тесты GUI (Streamlit)

Где находится:
- GUI‑тест: `tests/uitest/test_app_gui.py`
- Бутстрап для корректных импортов: `tests/uitest/app_bootstrap.py`
- Приложение Streamlit: `src/app.py`

Запуск GUI‑теста (идет вместе со всеми тестами):

```bash
make test
# или точечно:
pytest -q tests/uitest/test_app_gui.py
```

Что проверяется: успешный рендер приложения, взаимодействие с сайдбаром (слайдер, кнопка "Сгенерировать отзывы") без исключений.

## Makefile: быстрые команды

- `make test` — запустить все тесты.
- `make test-cov` — тесты с покрытием (terminal + XML).
- `make test-cov-html` — сгенерировать HTML‑отчет покрытия.
- `make profile` — профилирование `run_analysis` на наборах данных.
- `make web-perf` — веб‑нагрузочный тест для указанного сценария.
- `make clean` — очистить артефакты тестов и покрытия.

## Примечания

- Тесты и профилирование избегают сетевых вызовов и тяжелых моделей по умолчанию. Веб‑тест, естественно, делает HTTP‑запросы.
- Если тесты запускаются в ограниченной среде (sandbox/CI), используйте цели Makefile — они уже настроены на корректный запуск.

